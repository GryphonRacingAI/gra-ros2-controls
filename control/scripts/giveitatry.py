#!/usr/bin/env python3
import rclpy
from rclpy.node import Node

import numpy as np

from nav_msgs.msg import Odometry, Path
from ackermann_msgs.msg import AckermannDriveStamped


class MPPIController(Node):
    def __init__(self):
        super().__init__('mppi_controller')

        # ===== Subscriptions =====
        # Subscribe to odometry (vehicle state)
        self.odom_sub = self.create_subscription(
            Odometry, '/odom', self.odom_callback, 10
        )

        # Subscribe to the reference path generated by the path planner
        self.path_sub = self.create_subscription(
            Path, '/path', self.path_callback, 10
        )

        # ===== Publisher =====
        # Publish Ackermann control commands
        self.cmd_pub = self.create_publisher(
            AckermannDriveStamped, '/ackermann_cmd', 10
        )

        # ===== Internal variables =====
        self.state = None      # [x, y, yaw, v]
        self.path = None       # reference path (Nx2 numpy array)
        self.dt = 0.05         # control frequency (20 Hz)

        # Timer that triggers the control loop
        self.timer = self.create_timer(self.dt, self.control_loop)

        self.get_logger().info("MPPI Controller Node started.")


    # Callback for odometry messages

    def odom_callback(self, msg: Odometry):
        x = msg.pose.pose.position.x
        y = msg.pose.pose.position.y

        # TODO: Replace with proper quaternion->yaw conversion
        yaw = 0.0

        v = msg.twist.twist.linear.x
        self.state = np.array([x, y, yaw, v])


    # Callback for receiving the reference path

    def path_callback(self, msg: Path):
        pts = []
        for p in msg.poses:
            px = p.pose.position.x
            py = p.pose.position.y
            pts.append([px, py])

        if len(pts) > 0:
            self.path = np.array(pts)


    # Main control loop (runs every dt seconds)

    def control_loop(self):
        if self.state is None or self.path is None:
            return  # wait until both path and state are available


        # Placeholder control (for testing the node)
        # Replace with real MPPI algorithm later

        cmd = AckermannDriveStamped()
        cmd.drive.steering_angle = 0.0
        cmd.drive.speed = 1.0
        self.cmd_pub.publish(cmd)


def main(args=None):
    rclpy.init(args=args)
    node = MPPIController()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
